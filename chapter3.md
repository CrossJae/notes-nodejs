## 异步I/O

1. Overview
  1. 异步伴随AJAX的第一个A，Asynchronous大规模流行起来，程序员并不台适合通过异步来进行程序设计。
  2. PHP: 同步、阻塞，利用程序员顺序来编写业务逻辑，缺点就是在复杂的网络应用中，阻塞会导致无法并发。
  3. Node: 首个，以异步作为编程方式和设计理念的语言
  4. Nginx: 与node的事件驱动、异步I/O理念相近的产品是Nginx，采用纯C编写
    * 具备面向客户端管理连接的强大能力
    * 依然受限于各种同步方式的编程语言
    * 相比，node是全方位的，既可以作为服务端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。
2. 为什么要异步I/O
  1. 用户体验⚠️
    * 在浏览器中，JS在单线程上执行，它与UI渲染公用一个线程，意味着，JS在执行的时候，UI渲染和响应处于停滞状态的。如果脚本的执行超过100ms，用户就会觉得卡顿。如果是同步请求JS，则UI停顿，影响用户交互，所以异步请求下载资源的时候，JS和UI都不会停滞
    * 随着网站或应用不断膨胀，数据会分布到多台服务器上，分布式将会是常态。I/O是昂贵的，分布式I/O更昂贵。
    * 异步：主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性，导致代码难以理解。
  2. 资源分配
    * 单线程串行执行
      * 性能无法保证，会阻塞
    * 多线程并行完成
      * 锁、状态同步等问题
3. 异步I/O实现现状
  1. 异步/同步
  2. 阻塞/非阻塞
    * 阻塞I/O造成CPU等待浪费，非阻塞I/O需要 *轮寻* 确认是否完全完成数据获取
4. node的异步I/O
5. 非I/O的API
6. 事件驱动与高性能服务器
