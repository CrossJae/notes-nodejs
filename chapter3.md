## 异步I/O

1. Overview
  * 异步伴随AJAX的第一个A，Asynchronous大规模流行起来，程序员并不台适合通过异步来进行程序设计。
  * PHP: 同步、阻塞，利用程序员顺序来编写业务逻辑，缺点就是在复杂的网络应用中，阻塞会导致无法并发。
  * Node: 首个，以异步作为编程方式和设计理念的语言
  * Nginx: 与node的事件驱动、异步I/O理念相近的产品是Nginx，采用纯C编写
    * 具备面向客户端管理连接的强大能力
    * 依然受限于各种同步方式的编程语言
    * 相比，node是全方位的，既可以作为服务端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。
2. 为什么要异步I/O
  * 用户体验⚠️
    * 在浏览器中，JS在单线程上执行，它与UI渲染公用一个线程，意味着，JS在执行的时候，UI渲染和响应处于停滞状态的。如果脚本的执行超过100ms，用户就会觉得卡顿。如果是同步请求JS，则UI停顿，影响用户交互，所以异步请求下载资源的时候，JS和UI都不会停滞
    * 随着网站或应用不断膨胀，数据会分布到多台服务器上，分布式将会是常态。I/O是昂贵的，分布式I/O更昂贵。
    * 异步：主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性，导致代码难以理解。
  * 资源分配
    * 单线程串行执行
      * 性能无法保证，会阻塞
    * 多线程并行完成
      * 锁、状态同步等问题
3. 异步I/O实现现状
  * 异步/同步
  * 阻塞/非阻塞
    * 阻塞I/O造成CPU等待浪费，非阻塞I/O需要 *轮巡* 确认是否完全完成数据获取
4. node的异步I/O
  * 事件循环
    * Node自身的执行模式——事件循环
    * 每次执行一次循环体的过程成为Tick
    * 事件循环是一个典型的 生产者/消费者 模型
    * 在Node中，事件主要源于网路请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等
  * 观察者
    * 每个事件循环中有一个或者多个观察者，判断是否有事件要处理的过程就是向这些观察者询问是否需要处理的事件
  * 请求对象
    * 回调函数不由开发者调用，从发起调用到回调函数被执行，中间存在一种中间产物，就是请求对象。
    ```
    fs.open = function(path, flags, mode, callback){
      binding.open(pathModule, makelong(path), stringToFlags(flags), mode, callback);
    }
    ```
    * fs.open()作用是指定路径和参数去打开一个文件，从而得到一个文件描述符，这是后续所有I/O操作的初始操作。
    * 请求对象是异步I/O过程中的重要中间产物，所有状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理
  * 执行回调
    * I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，以此达到调用js中传入的回调函数的目的
  * 在node中，js是单线程的，node自身其实是多线程的。
5. 非I/O的API
  * 定时器
    * 缺点：非精确的，如果某一次循环占用时间多，那么下一次循环可能超时
  * `process.nextTick()`
  * `setImmediate()`
    * `process.nextTick()`的回调函数保存在数组里，`setImmediate()`的回调函数保存在链表里
6. 事件驱动与高性能服务器
  * Apache是每线程/每请求，Node通过事件驱动处理请求，不用创建和销毁进线程，上下文切换的代价很低。

*-end-*
